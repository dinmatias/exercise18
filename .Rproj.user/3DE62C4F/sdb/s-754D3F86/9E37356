{
    "collab_server" : "",
    "contents" : "evolvePop <- function(numGen, popSize1, iniFreq1,\n                      selReg, relFitness1, relFitness2,\n                      mig = FALSE,\n                      popSize2, iniFreq2,\n                      gf12, gf21){\n  \n  genoFreq1 <- vector(\"list\", length = (numGen + 1))\n  \n  if(mig){\n    \n    genoFreq2 <- vector(\"list\", length = (numGen + 1))\n    \n  }\n    \n  withProgress(message = 'Simulating', detail = \"Generation 0\", value = 0, min = 0, max = numGen, {\n    \n  for(generation in 1:numGen){\n    \n    if(generation == 1){\n      \n      parentalPool1 <- iniPop(freqA = iniFreq1, popSize = popSize1)\n      \n      genoFreq1[[generation]] <- parentalPool1\n      \n      if(mig){\n        parentalPool2 <- iniPop(freqA = iniFreq2, popSize = popSize2)\n        \n        genoFreq2[[generation]] <- parentalPool2\n      }\n      \n      \n    }\n    \n    # simulate migration prior to mating\n    if(mig){\n      \n      parentalPool1 <- sapply(1:popSize1,\n                              function(x){ \n                                migParent(gf = gf21,\n                                          setPool = parentalPool1,\n                                          migPool = parentalPool2,\n                                          setpopSize = popSize1)\n                                })\n      \n      parentalPool2 <- sapply(1:popSize2, \n                              function(x){\n                                migParent(gf = gf12, \n                                          setPool = parentalPool2, \n                                          migPool = parentalPool1,\n                                          setpopSize = popSize2)\n                                })\n      \n    }\n    \n    # mate\n    if(mig){\n      \n      parentalPool1 <- nextGeneration(popSize = popSize1,\n                                     parentalPool = parentalPool1,\n                                     selReg = selReg,\n                                     relFitness = relFitness1)\n      \n      parentalPool2 <- nextGeneration(popSize = popSize2,\n                                      parentalPool = parentalPool2,\n                                      selReg = selReg,\n                                      relFitness = relFitness1)\n    }else{\n      \n      parentalPool1 <- nextGeneration(popSize = popSize1,\n                                      parentalPool = parentalPool1,\n                                      selReg = selReg,\n                                      relFitness = relFitness1)\n    }\n    \n    if(mig){\n      \n      genoFreq1[[generation + 1]] <- parentalPool1\n      \n      genoFreq2[[generation + 1]] <- parentalPool2\n      \n    }else{\n      \n      genoFreq1[[generation + 1]] <- parentalPool1\n      \n    }\n    \n    incProgress(1, detail = paste(\"Generation\", (generation - 1)))\n    \n    \n    \n  } # END LOOP\n  })\n  \n  if(mig){\n    \n    resultPop1 <- lapply(genoFreq1, function(x) table(x))\n    \n    resultPop1 <- as.data.frame.matrix(do.call(rbind, resultPop1))\n    \n    resultPop1$Generation <- 0:numGen\n    \n    resultPop1$freqA <- apply(resultPop1, 1, function(x) ((x[1] * 2) + x[2]) / (2 * sum(x[1:3])))\n    \n    resultPop2 <- lapply(genoFreq2, function(x) table(x))\n    \n    resultPop2 <- as.data.frame.matrix(do.call(rbind, resultPop2))\n    \n    resultPop2$Generation <- 0:numGen\n    \n    resultPop2$freqA <- apply(resultPop2, 1, function(x) ((x[1] * 2) + x[2]) / (2 * sum(x[1:3])))\n    \n    result <- data.frame(Generation = resultPop1[ , 4],\n                         Pop1AA = resultPop1[ , 1], Pop1Aa = resultPop1[ , 2], \n                         Pop1aa = resultPop1[ , 3], Pop1freqA = resultPop1[ , 5],\n                         Pop2AA = resultPop2[ , 1], Pop2Aa = resultPop2[ , 2], \n                         Pop2aa = resultPop2[ , 3], Pop2freqA = resultPop2[ , 5])\n    \n    return(result)\n    \n  }else{\n\n    resultPop1 <- lapply(genoFreq1, function(x) table(x))\n    \n    resultPop1 <- as.data.frame.matrix(do.call(rbind, resultPop1))\n    \n    resultPop1$Generation <- 0:numGen\n    \n    resultPop1$freqA <- apply(resultPop1, 1, function(x) ((x[1] * 2) + x[2]) / (2 * sum(x[1:3])))\n    \n    result <- data.frame(Generation = resultPop1[ , 4],\n                         Pop1AA = resultPop1[ , 1], Pop1Aa = resultPop1[ , 2], \n                         Pop1aa = resultPop1[ , 3], Pop1freqA = resultPop1[ , 5])\n    \n    return(result)\n    \n  }\n  \n}\n\nselection <- function(popSize, parentalPool, relFitness = c(1, 1, 1)){\n  \n  accGeno <- factor(levels = levels(parentalPool))\n  \n  iniPoolIndex <- 1:popSize\n  \n  numPar = 1\n  \n  while(numPar <= 2){\n    \n    indexPar <- sample(x = iniPoolIndex, size = 1, replace = FALSE)\n    \n    parGeno <- parentalPool[indexPar]\n    \n    if(relFitness[parGeno] > runif(n = 1, min = 0, max = 1)){\n      \n      iniPoolIndex <- iniPoolIndex[-indexPar]\n      accGeno[numPar] <- parGeno\n      numPar = numPar + 1\n      \n    }\n    \n  }\n  \n  return(accGeno)\n  \n}\n\n\nchooseParent <- function(popSize, parentalPool, selReg = FALSE, relFitness = c(1, 1, 1)){\n  \n    # Selection\n    if(selReg){\n      \n      accGeno <- selection(popSize = popSize, parentalPool = parentalPool, \n                           relFitness = relFitness)\n\n    }else{\n      \n      indexPar <- sample(x = 1:popSize, size = 2, replace = FALSE)\n      \n      accGeno <- parentalPool[indexPar]\n      \n\n    }\n\n  return(accGeno)\n  \n}\n\nproduceOffspring <- function(parentGeno){\n  \n  alleles <- sapply(strsplit(as.character(parentGeno), \"\"),\n                    function(x) sample(x, 1))\n  \n  offspring <- paste(sort(alleles, decreasing = TRUE), collapse = \"\")\n  \n  return(offspring)\n  \n}\n\niniPop <- function(freqA, popSize){\n  \n  x <- sapply(1:round(popSize), \n              function(x) { sample(x = c(\"A\", \"a\"), size = 2, \n                                   prob = c(freqA, (1- freqA)), \n                                   replace = TRUE) })\n  \n  x <- t(x)\n  \n  x <- paste(x[ , 1], x[ , 2], sep = \"\")\n  \n  x <- ifelse(x == \"aA\", \"Aa\", x)\n  \n  x <- factor(x, levels = c(\"AA\", \"Aa\", \"aa\"))\n  \n  levels(x) <- c(\"AA\", \"Aa\", \"aa\")\n  \n  return(x)\n  \n}\n\n\nnextGeneration <- function(popSize, parentalPool, selReg, relFitness = c(1, 1, 1)){\n  \n  x <- sapply(1:popSize, function(x) { \n    parentGeno <- chooseParent(popSize = popSize,\n                               parentalPool = parentalPool, \n                               selReg = selReg, \n                               relFitness = relFitness)\n    \n    x <- produceOffspring(parentGeno = parentGeno)\n    \n    return(x)\n    \n  })\n  \n  x <- factor(x, levels = c(\"AA\", \"Aa\", \"aa\"))\n  \n  return(x)\n  \n}\n\n\nmigParent <- function(gf, setPool, migPool, setpopSize){\n  \n  # if draw is greater than, then it is not a migration\n  # gf12/popSize2 is the probability that individual in population 2 is from population 1\n  if(runif(1, 0, 1) > gf/setpopSize){\n    # then simply  draw an indivual from population 2\n    parent <- sample(setPool, 1)\n    \n  }else{\n    \n    parent <- sample(migPool, 1)\n    \n  }\n  \n  return(parent)\n  \n  \n}\n\n",
    "created" : 1504549361356.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "209675373",
    "id" : "9E37356",
    "lastKnownWriteTime" : 1504371478,
    "last_content_update" : 1504371478,
    "path" : "D:/Dropbox/exercise18/functions/simfunctions.R",
    "project_path" : "functions/simfunctions.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}